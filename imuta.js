// Generated by CoffeeScript 1.9.2
(function() {
  var slice = [].slice;

  window.Imuta = {
    clone: function(some) {
      switch (Object.prototype.toString.call(some)) {
        case "[object Undefined]":
          return void 0;
        case "[object Boolean]":
          return some;
        case "[object Number]":
          return some;
        case "[object String]":
          return some;
        case "[object Function]":
          return new function() {
            return some;
          };
        case "[object Null]":
          return null;
        case "[object Array]":
          return some.map(function(el) {
            return Imuta.clone(el);
          });
        case "[object Object]":
          return Object.keys(some).reduce((function(acc, k) {
            acc[Imuta.clone(k)] = Imuta.clone(some[k]);
            return acc;
          }), {});
      }
    },
    equal: function(a, b) {
      var i, keys_a, keys_b, len_a, len_b, ref, ref1, results, type_a, type_b;
      if (a === b) {
        return true;
      } else {
        ref = [Object.prototype.toString.call(a), Object.prototype.toString.call(b)], type_a = ref[0], type_b = ref[1];
        if (type_a === type_b) {
          switch (type_a) {
            case "[object Undefined]":
              return true;
            case "[object Boolean]":
              return a === b;
            case "[object Number]":
              return a === b;
            case "[object String]":
              return a === b;
            case "[object Function]":
              return false;
            case "[object Null]":
              return true;
            case "[object Array]":
              len_a = a.reduce((function(acc, _) {
                return acc + 1;
              }), 0);
              len_b = b.reduce((function(acc, _) {
                return acc + 1;
              }), 0);
              if (len_a === len_b) {
                return (function() {
                  results = [];
                  for (var i = 0; 0 <= len_a ? i <= len_a : i >= len_a; 0 <= len_a ? i++ : i--){ results.push(i); }
                  return results;
                }).apply(this).every(function(n) {
                  return Imuta.equal(a[n], b[n]);
                });
              } else {
                return false;
              }
              break;
            case "[object Object]":
              ref1 = [a, b].map(function(obj) {
                var _, k, lst;
                lst = [];
                for (k in obj) {
                  _ = obj[k];
                  lst.push(k);
                }
                return lst.sort();
              }), keys_a = ref1[0], keys_b = ref1[1];
              if (Imuta.equal(keys_a, keys_b)) {
                return keys_a.every(function(k) {
                  return Imuta.equal(a[k], b[k]);
                });
              } else {
                return false;
              }
          }
        } else {
          return false;
        }
      }
    },
    is_undefined: function(some) {
      return Object.prototype.toString.call(some) === "[object Undefined]";
    },
    is_boolean: function(some) {
      return Object.prototype.toString.call(some) === "[object Boolean]";
    },
    is_number: function(some) {
      return Object.prototype.toString.call(some) === "[object Number]";
    },
    is_string: function(some) {
      return Object.prototype.toString.call(some) === "[object String]";
    },
    is_function: function(some) {
      return Object.prototype.toString.call(some) === "[object Function]";
    },
    is_null: function(some) {
      return Object.prototype.toString.call(some) === "[object Null]";
    },
    is_list: function(some) {
      return Object.prototype.toString.call(some) === "[object Array]";
    },
    is_map: function(some) {
      return Object.prototype.toString.call(some) === "[object Object]";
    },
    flatten: function(some) {
      if (Imuta.is_list(some)) {
        return some.reduce((function(acc, el) {
          if (Imuta.is_list(el)) {
            return acc.concat(Imuta.flatten(el));
          } else {
            acc.push(Imuta.clone(el));
            return acc;
          }
        }), []);
      } else {
        throw new Error("Get not list input in Imuta.flatten func");
      }
    },
    put_in: function(obj, path, value) {
      var head, tail;
      if (path.length === 0) {
        throw new Error("put_in func failed, empty path");
      }
      head = path[0], tail = 2 <= path.length ? slice.call(path, 1) : [];
      if (tail.length === 0) {
        obj[head] = Imuta.clone(value);
        return obj;
      } else {
        if (obj.hasOwnProperty(head)) {
          obj[head] = Imuta.put_in(obj[head], tail, value);
          return obj;
        } else {
          throw new Error("put_in func failed, obj has no property " + head);
        }
      }
    },
    get_in: function(obj, path) {
      var head, tail;
      if (path.length === 0) {
        throw new Error("get_in func failed, empty path");
      }
      head = path[0], tail = 2 <= path.length ? slice.call(path, 1) : [];
      if (obj.hasOwnProperty(head)) {
        if (tail.length === 0) {
          return Imuta.clone(obj[head]);
        } else {
          return Imuta.get_in(obj[head], tail);
        }
      } else {
        return void 0;
      }
    },
    update_in: function(obj, path, func) {
      var head, tail;
      if (path.length === 0) {
        throw new Error("update_in func failed, empty path");
      }
      head = path[0], tail = 2 <= path.length ? slice.call(path, 1) : [];
      if (obj.hasOwnProperty(head)) {
        if (tail.length === 0) {
          if (Imuta.is_function(func) && (func.length === 1)) {
            obj[head] = Imuta.clone(func(obj[head]));
            return obj;
          } else {
            throw new Error("Get not function/1 handler in update_in func");
          }
        } else {
          obj[head] = Imuta.update_in(obj[head], tail, func);
          return obj;
        }
      } else {
        throw new Error("update_in func failed, obj has no property " + head);
      }
    }
  };

}).call(this);
